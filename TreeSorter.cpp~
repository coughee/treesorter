#include "TreeSorter.h"

TreeSorter::TreeSorter(){

};

void TreeSorter::sortTree(){
  //First find the ordered list of end nodes.
  findEndNodesInOrder(0);
  int firstIndex = tree.size() - endNodesInOrder.size();
  int curEndNode = 0;
  //Then loop over the tree nodes and swap with the end node.
  for(int i = firstIndex; i < tree.size(); i++){
    curEndNode = i - firstIndex;
    tree.swap(i,endNodesInOrder[curEndNode]);
    if(tree.nodes[i].isEndNode){
      //update end Node positions.
      endNodesInOrder[findInEndNodeList(i)] = endNodesInOrder[curEndNode];
    } 
  }
}

int TreeSorter::findInEndNodeList(int i){
  for(int j = 0; j < endNodesInOrder.size(); j++){
    if(endNodesInOrder[j] == i){
      return j;
    }
  }
}

void TreeSorter::findEndNodes(){
  endNodes.clear();
  for(int i = 0; i < tree.size(); i++){
    if(tree.nodes[i].isEndNode){
      endNodes.push_back(i);
    }
  }
}

void TreeSorter::findEndNodesInOrder(int id){
  //Recursive algorithm
  if(tree.nodes[id].isEndNode){
    endNodesInOrder.push_back(id);
    return;
  }
  else{
    findEndNodesInOrder(tree.nodes[id].c1);
    findEndNodesInOrder(tree.nodes[id].c2);
  }
}

void TreeSorter::extendTree(){
  findEndNodes();
  for(int i = 0; i < endNodes.size(); i++){
    insertSymTree(endNodes[i]);
  }
}

void TreeSorter::insertSymTree(int endNode){

}

void TreeSorter::makeSymTree(int depth){
  Node temp;
  double size = (int)pow(2, depth) - 1;
  int tempP = 0, tempC1 = 0, tempC2 = 0;

  bool tempIsBlocked, tempIsEndNode = false;
  symmTree.resize(size);

  for(int i = 0; i < size; i++){
    tempC1 = 2*i + 1;
    tempC2 = 2*i + 2;
    tempP = (int)floor((i - 1) / 2);
    tempIsBlocked = false;
    if(i < floor((size - 1)/2)){
      tempIsEndNode = false;

    }
    else{
      tempIsEndNode = true;
    }
    symmTree[i].x = 0;
    symmTree[i].y = 0;
    symmTree[i].z = 0;
    symmTree[i].parent = tempP;
    symmTree[i].child1 = tempC1;
    symmTree[i].child2 = tempC2;
    symmTree[i].isEndNode = tempIsEndNode;
  }

  int count = 0;
  for(int i = 0; i < symmTree.size(); i++){
    if(symmTree[i].isEndNode){
      count++;
    }
  }
  double tempRadius = pow(pow(rootRadius, bifurcationExponent)/(double)count,1.0/bifurcationExponent);

  for(int i = 0; i < symmTree.size(); i++){
    if(symmTree[i].isEndNode){
      symmTree[i].radius = tempRadius;
    }
  }
    

}

//Input and Output
void TreeSorter::outputTree(char* outputfilename){

}

void TreeSorter::readTree(char* filename){

}


